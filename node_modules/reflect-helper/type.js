require("reflect-metadata");
var property_1 = require("./property");
var util_1 = require("./util");
var method_1 = require("./method");
/**
 * Information on a concrete type.
 *
 * <uml>
 * hide members
 * hide circle
 * Type *-- Property : properties
 * Type *-- Method : methods
 * Type <-- Type : baseType
 * </uml>
 */
var Type = (function () {
    /**
     * Creates a type object.
     * @param context The [[ReflectContext]] that is managing this type.
     * @param ctr The constructor function for the type.
     * @hidden
     */
    function Type(context, ctr) {
        if (!ctr) {
            throw new Error("Missing required argument 'ctr'.");
        }
        this.ctr = ctr;
        this.name = ctr === void 0 ? "undefined" : ctr.name;
        this._context = context;
    }
    Type.prototype.getAnnotations = function (inheritOrAnnotationCtr, inherit) {
        var annotationCtr;
        if (typeof inheritOrAnnotationCtr === "function") {
            annotationCtr = inheritOrAnnotationCtr;
        }
        else if (typeof inheritOrAnnotationCtr === "boolean") {
            inherit = inheritOrAnnotationCtr;
        }
        var annotations = util_1.matchingAnnotations(annotationCtr, this._getOwnMetadata());
        if (inherit) {
            var baseType = this.baseType;
            if (baseType) {
                annotations = baseType.getAnnotations(annotationCtr, inherit).concat(annotations);
            }
        }
        return annotations;
    };
    /**
     * Checks if the type has the specified type of annotation.
     * @param annotationCtr The constructor function for the annotation to look for.
     * @param inherit Indicates if base types should be checked as well. Default false.
     */
    Type.prototype.hasAnnotation = function (annotationCtr, inherit) {
        return this.getAnnotations(annotationCtr, inherit).length > 0;
    };
    /**
     * Returns true if the current type is a subtype of the specified type; otherwise, returns false.
     * @param type The [[Type]] or constructor function to check.
     */
    Type.prototype.isSubtypeOf = function (type) {
        var isFunction = typeof type === "function";
        var baseType = this.baseType;
        while (baseType) {
            if (isFunction ? baseType.ctr === type : baseType === type)
                return true;
            baseType = baseType.baseType;
        }
        return false;
    };
    /**
     * Returns true if the current type can be assigned to the specified type; otherwise, return false.
     *
     * This happens if one of the two conditions are met:
     *  * The current type and the specified type are the same type.
     *  * The current type is a subtype of the specified type.
     *
     * @param type The [[Type]] or constructor function to check.
     */
    Type.prototype.isAssignableTo = function (type) {
        if (typeof type === "function" ? this.ctr === type : this === type)
            return true;
        return this.isSubtypeOf(type);
    };
    Object.defineProperty(Type.prototype, "properties", {
        /**
         * A list of annotated properties for the type.
         */
        get: function () {
            var _this = this;
            if (!this._properties) {
                this._properties = this._getPropertyNames().map(function (name) {
                    return new property_1.Property(_this._context, _this, name);
                });
            }
            return this._properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the property with the specified name.
     * @param name The property name to find.
     */
    Type.prototype.getProperty = function (name) {
        var properties = this.properties;
        for (var i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (property.name == name) {
                return property;
            }
        }
        return null;
    };
    Object.defineProperty(Type.prototype, "methods", {
        /**
         * A list of methods for the type. Methods are available whether or not they are annotated.
         */
        get: function () {
            var _this = this;
            if (!this._methods) {
                this._methods = this._getMethodNames().map(function (name) {
                    return new method_1.Method(_this._context, _this, name);
                });
            }
            return this._methods;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "baseType", {
        /**
         * The base type for the current type.
         */
        get: function () {
            if (this._baseType === undefined) {
                this._baseType = this._context.getType(this._getBaseType());
            }
            return this._baseType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isNumber", {
        /**
         * Indicates if the type is the global Number type.
         */
        get: function () {
            return this.ctr === Number;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isString", {
        /**
         * Indicates if the type is the global String type.
         */
        get: function () {
            return this.ctr === String;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isBoolean", {
        /**
         * Indicates if the type is the global Boolean type.
         */
        get: function () {
            return this.ctr === Boolean;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isArray", {
        /**
         * Indicates if the type is the global Array type.
         */
        get: function () {
            return this.ctr === Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isSet", {
        /**
         * Indicates if the type is the global Set type.
         */
        get: function () {
            return this.ctr === Map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isFunction", {
        /**
         * Indicates if the type is the global Function type.
         */
        get: function () {
            return this.ctr === Function;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Type.prototype, "isIterable", {
        /**
         * Indicates if the type is iterable (i.e. the type defines a method for Symbol.iterator).
         */
        get: function () {
            if (this.ctr == null || this.ctr.prototype == null) {
                return false;
            }
            return this.ctr.prototype[Symbol.iterator] !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates an instance of the type with the specified arguments.
     * @param args The arguments to pass to the constructor.
     * @returns An instance of the type.
     */
    Type.prototype.createInstance = function (args) {
        if (!args) {
            return new this.ctr();
        }
        else {
            return new ((_a = this.ctr).bind.apply(_a, [void 0].concat(args)))();
        }
        var _a;
    };
    /**
     * Gets the base type of the current type.
     * @hidden
     */
    Type.prototype._getBaseType = function () {
        var basePrototype = this.ctr && this.ctr.prototype && Object.getPrototypeOf(this.ctr.prototype);
        return basePrototype && basePrototype.constructor;
    };
    /**
     * Gets a list of annotated properties for the type that are not methods.
     * @hidden
     */
    Type.prototype._getPropertyNames = function () {
        var _this = this;
        var properties = Reflect.getOwnMetadata('propMetadata', this.ctr);
        if (properties) {
            return Object.getOwnPropertyNames(properties)
                .filter(function (p) { return isAccessor(_this.ctr.prototype, p) || typeof _this.ctr.prototype[p] !== "function"; });
        }
        return [];
    };
    /**
     * Gets a list of methods for the type.
     * @hidden
     */
    Type.prototype._getMethodNames = function () {
        var _this = this;
        if (this.ctr) {
            return Object.getOwnPropertyNames(this.ctr.prototype)
                .filter(function (p) { return p != "constructor" && (isAccessor(_this.ctr.prototype, p) || typeof _this.ctr.prototype[p] === "function"); });
        }
        return [];
    };
    /**
     * Gets a list of annotations for the type.
     * @hidden
     */
    Type.prototype._getOwnMetadata = function () {
        return Reflect.getOwnMetadata('annotations', this.ctr) || [];
    };
    return Type;
})();
exports.Type = Type;
function isAccessor(obj, p) {
    var d = Object.getOwnPropertyDescriptor(obj, p);
    return !!(d && (d.get || d.set));
}
