// The code for makeDecorator is originally based on code from Angular 2.
require("reflect-metadata");
/**
 * Returns the list of annotations that are an instance of the specified annotation type.
 * @param annotationCtr The constructor for the annotation
 * @param annotations A list of annotations to filter
 * @hidden
 */
function matchingAnnotations(annotationCtr, annotations) {
    if (annotationCtr) {
        annotations = annotations.filter(function (annotation) { return annotation instanceof annotationCtr; });
    }
    return annotations;
}
exports.matchingAnnotations = matchingAnnotations;
/**
 * Makes a decorator factory from an annotation. The resulting decorator factory can be applied to a class or property.
 * @param annotationCtr The annotation constructor.
 *
 *
 * ### Example
 *
 * An annotation is just a class. So, supposed with have an annotation that marks a class as a persistent entity as
 * follows:
 *
 * ```typescript
 *  class EntityAnnotation {
 *
 *      constructor(public name?: string) {
 *      }
 *  }
 * ```
 *
 * We can turn that annotation into a class decorator. When applied, an instance of the annotation
 * is created and added to the 'annotations' metadata for the class. The parameters for the decorator will be the same
 * as the parameters for the class constructor. However, we may want to provide a type annotation for the decorator
 * factory because the parameters cannot be inferred.
 *
 * ```typescript
 *  var Entity: (name?: string) => ClassDecorator = makeDecorator(EntityAnnotation);
 * ```
 *
 * The Entity decorator can be applied as follows:
 * ```typescript
 * Â @Entity()
 *  class Person {
 *
 *  }
 * ```
 */
function makeDecorator(annotationCtr) {
    // The code for this function is adapted from https://github.com/angular/angular/blob/master/modules/angular2/src/core/util/decorators.ts
    return function DecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var annotationInstance = new (annotationCtr.bind.apply(annotationCtr, [void 0].concat(args)))();
        return function Decorator(target, propertyName, parameterIndex) {
            // check for parameter annotation
            if (typeof parameterIndex === "number") {
                var parameters = Reflect.getMetadata('parameters', target, propertyName);
                parameters = parameters || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= parameterIndex) {
                    parameters.push(null);
                }
                parameters[parameterIndex] = parameters[parameterIndex] || [];
                var annotationsForParam = parameters[parameterIndex];
                annotationsForParam.push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, target, propertyName);
            }
            else if (propertyName) {
                var properties = Reflect.getOwnMetadata('propMetadata', target.constructor);
                properties = properties || {};
                properties[propertyName] = properties[propertyName] || [];
                properties[propertyName].push(annotationInstance);
                Reflect.defineMetadata('propMetadata', properties, target.constructor);
            }
            else {
                var annotations = Reflect.getOwnMetadata('annotations', target) || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, target);
            }
        };
    };
}
exports.makeDecorator = makeDecorator;
function decorate(target, decoratorsOrProperties, properties) {
    var decorators;
    if (Array.isArray(decoratorsOrProperties)) {
        decorators = decoratorsOrProperties;
    }
    if (typeof decoratorsOrProperties === "object") {
        properties = decoratorsOrProperties;
    }
    else if (typeof decoratorsOrProperties === "function") {
        decorators = [decoratorsOrProperties];
    }
    if (decorators) {
        Reflect.decorate(decorators, target);
    }
    if (properties) {
        for (var p in properties) {
            if (properties.hasOwnProperty(p)) {
                if (!Array.isArray(properties[p])) {
                    var propDecorators = [properties[p]];
                }
                else {
                    var propDecorators = properties[p];
                }
                if (target.prototype[p] === "function") {
                    Reflect.decorate(propDecorators, target.prototype, p, Object.getOwnPropertyDescriptor(target.prototype, p));
                }
                else {
                    Reflect.decorate(propDecorators, target.prototype, p);
                }
            }
        }
    }
}
exports.decorate = decorate;
