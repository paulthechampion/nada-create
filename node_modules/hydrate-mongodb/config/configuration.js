"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async = require("async");
var namingStrategies_1 = require("./namingStrategies");
var mappingRegistry_1 = require("../mapping/mappingRegistry");
var sessionFactory_1 = require("../sessionFactory");
var objectIdGenerator_1 = require("./objectIdGenerator");
var persistenceError_1 = require("../persistenceError");
/**
 * Specifies default settings used to create the [[SessionFactory]].
 */
var Configuration = /** @class */ (function () {
    function Configuration() {
        /**
         * Default identity generator to use.
         */
        this.identityGenerator = new objectIdGenerator_1.ObjectIdGenerator();
        /**
         * True if entities are versioned by default; otherwise, false.
         */
        this.versioned = true;
        /**
         * True if null values should be saved for properties by default; otherwise, false.
         */
        this.nullable = false;
        /**
         * Default field name to use for optimistic locking.
         */
        this.versionField = "__v";
        /**
         * Default field name to use for the class discriminator.
         */
        this.discriminatorField = "__t";
        /**
         * Default change tracking strategy to use.
         */
        this.changeTracking = 1 /* DeferredImplicit */;
        /**
         * Naming strategy to use for collection names.
         */
        this.collectionNamingStrategy = namingStrategies_1.NamingStrategies.CamelCase;
        /**
         * Naming strategy to use for field names.
         */
        this.fieldNamingStrategy = namingStrategies_1.NamingStrategies.CamelCase;
        /**
         * Naming strategy to use for the discriminator value of a class.
         */
        this.discriminatorNamingStrategy = namingStrategies_1.NamingStrategies.None;
        /**
         * Named property converters.
         */
        this.propertyConverters = {};
        /**
         * @hidden
         */
        this._mappings = [];
    }
    /**
     * Adds a mapping provider to the configuration.
     * @param mapping The mapping provider to use.
     */
    Configuration.prototype.addMapping = function (mapping) {
        this._mappings.push(mapping);
    };
    Configuration.prototype.createSessionFactory = function (connection, callbackOrDatabaseName, callback) {
        var _this = this;
        var registry = new mappingRegistry_1.MappingRegistry(), databaseName;
        if (typeof callbackOrDatabaseName === "function") {
            callback = callbackOrDatabaseName;
        }
        else {
            databaseName = callbackOrDatabaseName;
        }
        if (!this._mappings || this._mappings.length == 0) {
            return callback(new persistenceError_1.PersistenceError("No mappings were added to the configuration."));
        }
        // Get the mappings from the mapping providers
        async.each(this._mappings, function (provider, done) {
            provider.getMapping(_this, function (err, r) {
                if (err)
                    return done(err);
                // Merge all registries. Duplicates will cause an error.
                registry.addMappings(r);
                done();
            });
        }, function (err) {
            if (err)
                return callback(err);
            _this._buildCollections(connection, databaseName, registry, function (err, collections) {
                if (err)
                    return callback(err);
                var factory = new sessionFactory_1.SessionFactoryImpl(connection, collections, registry);
                factory.logger = _this.logger;
                // see if creating indexes is enabled
                if (!_this.createIndexes) {
                    callback(null, factory);
                }
                else {
                    factory.createIndexes(function (err) {
                        if (err)
                            return callback(err);
                        callback(null, factory);
                    });
                }
            });
        });
    };
    /**
     * @hidden
     */
    Configuration.prototype._buildCollections = function (connection, databaseName, registry, callback) {
        var _this = this;
        // Get all the collections and make sure they exit. We can also use this as a chance to build the
        // collection if it does not exist.
        var collections = [];
        var namesSeen = new Map();
        async.each(registry.getEntityMappings(), function (mapping, done) {
            if (!(mapping.flags & 4096 /* InheritanceRoot */)) {
                process.nextTick(done);
                return;
            }
            // make sure we have a collection name
            if (!mapping.collectionName) {
                return done(new persistenceError_1.PersistenceError("Missing collection name on mapping for type '" + mapping.name + "'."));
            }
            var dbName = mapping.databaseName || databaseName || _this.databaseName;
            if (!dbName) {
                return done(new Error("Could not determine database name for '" + mapping.collectionName + "'. Please make sure to specify "
                    + "the database name in either the Configuration, the call to createSessionFactory, or the @Collection decorator."));
            }
            // make sure db/collection is not mapped to some other type.
            var key = dbName + "/" + mapping.collectionName;
            if (namesSeen.has(key)) {
                return done(new persistenceError_1.PersistenceError("Duplicate collection name '" + key + "' on type '" + mapping.name + "' ."));
            }
            namesSeen.set(key, true);
            var db = connection.db(dbName);
            db.listCollections({ name: mapping.collectionName }).toArray(function (err, names) {
                if (err)
                    return done(err);
                if (names.length == 0) {
                    db.createCollection(mapping.collectionName, mapping.collectionOptions || {}, function (err, collection) {
                        if (err)
                            return done(err);
                        collections[mapping.id] = collection;
                        process.nextTick(done);
                    });
                }
                else {
                    // collection exists, get it
                    db.collection(mapping.collectionName, { strict: true }, function (err, collection) {
                        if (err)
                            return done(err);
                        collections[mapping.id] = collection;
                        process.nextTick(done);
                    });
                }
            });
        }, function (err) {
            if (err)
                return callback(err);
            callback(null, collections);
        });
    };
    return Configuration;
}());
exports.Configuration = Configuration;
