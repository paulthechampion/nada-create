"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var resolveContext_1 = require("./resolveContext");
var persistenceError_1 = require("../persistenceError");
var nextMappingId = 1;
var MappingBase = (function () {
    function MappingBase(flags) {
        this.flags = flags;
        this.id = nextMappingId++;
    }
    MappingBase.prototype.hasFlags = function (flags) {
        return this.flags != undefined && ((this.flags & flags) === flags);
    };
    MappingBase.prototype.watch = function (value, observer, visited) {
    };
    MappingBase.prototype.walk = function (session, value, flags, entities, embedded, references) {
    };
    MappingBase.prototype.areEqual = function (documentValue1, documentValue2) {
        if (documentValue1 === documentValue2)
            return true;
        if (documentValue1 == null || documentValue2 == null)
            return false;
        if (documentValue1 !== documentValue1 && documentValue2 !== documentValue2)
            return true;
        return false;
    };
    MappingBase.prototype.fetch = function (session, parentEntity, value, path, depth, callback) {
        if (depth == path.length) {
            process.nextTick(function () { return callback(null, value); });
            return;
        }
        callback(new persistenceError_1.PersistenceError("Undefined property '" + path[depth] + "' in path '" + path.join(".") + "'."));
    };
    MappingBase.prototype.fetchInverse = function (session, parentEntity, propertyName, path, depth, callback) {
        callback(new persistenceError_1.PersistenceError("Mapping does not support inverse relationships."));
    };
    MappingBase.prototype.resolve = function (pathOrContext) {
        var context, path;
        if (typeof pathOrContext === "string") {
            path = pathOrContext;
            if (!this._resolveCache) {
                this._resolveCache = new Map();
            }
            else {
                var context = this._resolveCache.get(path);
                if (context) {
                    return context;
                }
            }
            context = new resolveContext_1.ResolveContext(path);
        }
        else {
            context = pathOrContext;
        }
        this.resolveCore(context);
        if (path) {
            this._resolveCache.set(path, context);
        }
        return context;
    };
    MappingBase.prototype.resolveCore = function (context) {
        if (!context.isEop) {
            context.setError("Undefined property.");
        }
    };
    return MappingBase;
}());
exports.MappingBase = MappingBase;
