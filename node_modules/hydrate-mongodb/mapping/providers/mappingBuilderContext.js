"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reflect_helper_1 = require("reflect-helper");
var mappingModel_1 = require("../mappingModel");
var MappingBuilderContext = (function () {
    function MappingBuilderContext(config) {
        this.errors = [];
        this._builders = new Map();
        this._typesByName = new Map();
        this.config = config;
        this._reflect = new reflect_helper_1.ReflectContext();
    }
    MappingBuilderContext.prototype.populateMappings = function () {
        var _this = this;
        var classMappings = [];
        this._builders.forEach(function (mappedType) {
            _this.currentType = mappedType.type;
            mappedType.populate();
            if (mappedType.mapping.flags & 4) {
                classMappings.push(mappedType.mapping);
            }
        });
        this.currentType = null;
        return classMappings;
    };
    MappingBuilderContext.prototype.addError = function (message) {
        if (this.currentAnnotation) {
            message = "Invalid annotation " + this.currentAnnotation.toString() + ": " + message;
        }
        if (this.currentMethod) {
            message = "Error processing method '" + this.currentMethod.name + "' on type '" + this.currentMethod.parent.name + "': " + message;
        }
        else if (this.currentProperty) {
            message = "Error processing property '" + this.currentProperty.name + "' on type '" + this.currentProperty.parent.name + "': " + message;
        }
        else if (this.currentType) {
            message = "Error processing type '" + this.currentType.name + "': " + message;
        }
        this.errors.push(message);
    };
    MappingBuilderContext.prototype.getType = function (type) {
        if (typeof type === "string") {
            var resolved = this._typesByName.get(type);
            if (!resolved) {
                this.addError("Unknown type '" + type + "'.");
                return;
            }
            return resolved;
        }
        return this._reflect.getType(type);
    };
    MappingBuilderContext.prototype.addBuilder = function (mappedType) {
        if (!mappedType)
            return;
        if (this._typesByName.has(mappedType.type.name)) {
            this.addError("Duplicate class name '" + mappedType.type.name + "'. All named types must have unique names.");
        }
        this._typesByName.set(mappedType.type.name, mappedType.type);
        this._builders.set(mappedType.type, mappedType);
    };
    MappingBuilderContext.prototype.getBuilder = function (type) {
        if (!type)
            return null;
        return this._builders.get(type);
    };
    MappingBuilderContext.prototype.hasBuilder = function (type) {
        return this._builders.has(type);
    };
    MappingBuilderContext.prototype.assertClassMapping = function (mapping) {
        if (!(mapping.flags & 4)) {
            this.addError("Annotation can only be defined on class mappings.");
            return false;
        }
        return true;
    };
    MappingBuilderContext.prototype.assertEmbeddableMapping = function (mapping) {
        if ((mapping.flags & 2048) === 0) {
            this.addError("Annotation can only be defined an embeddable class.");
            return false;
        }
        return true;
    };
    MappingBuilderContext.prototype.assertRootClassMapping = function (mapping) {
        if (!this.assertClassMapping(mapping))
            return false;
        var classMapping = mapping;
        if (!(classMapping.flags & 4096)) {
            this.addError("Annotation can only be defined on classes that are the root of a mapped inheritance hierarchy.");
        }
        return true;
    };
    MappingBuilderContext.prototype.assertRootEntityMapping = function (mapping) {
        if (!this.assertEntityMapping(mapping))
            return false;
        return this.assertRootClassMapping(mapping);
    };
    MappingBuilderContext.prototype.assertEntityMapping = function (mapping) {
        if (!(mapping.flags & 1024)) {
            this.addError("Annotation can only be defined on entities.");
            return false;
        }
        return true;
    };
    return MappingBuilderContext;
}());
exports.MappingBuilderContext = MappingBuilderContext;
