import { Constructor, ParameterlessConstructor } from "../../index";
import { FieldDescription, CollectionDescription, ClassIndexDescription, PropertyIndexDescription } from "./annotations";
import { PropertyConverter, FetchType } from "../mappingModel";
import { ChangeTrackingType } from "../mappingModel";
import { CascadeFlags } from "../mappingModel";
import { IdentityGenerator } from "../../config/configuration";
/**
 * Specifies that a class is a persistent entity and will be serialized to a document within a MongoDB collection.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Task {
 *     ...
 *  }
 * ```
 */
export declare function Entity(): ClassDecorator;
/**
 * Specifies that a class can be embedded as a subdocument within an entity, array, or another embeddable.
 *
 * ### Example
 *
 * ```typescript
 *  @Embeddable()
 *  export class Address {
 *     ...
 *  }
 * ```
 */
export declare function Embeddable(): ClassDecorator;
/**
 * Specifies the property converter to use.
 *
 * See [[PropertyConverter]] for more information on creating property converts. The Converter decorator can be used at
 * the class or property level. The decorator accepts an instance of a PropertyConverter, the parameterless constructor
 * for a PropertyConverter, or a string for a named PropertyConverter.
 *
 * ### Example
 *
 * The example below defines the property converter on the Point class. In this case the convert is used for all
 * instances of the Point class.
 * ```typescript
 *  @Converter(PointConverter)
 *  export class Point {
 *
 *     x: number;
 *     y: number;
 *  }
 * ```
 *
 * The example below defines the property converter as an instance of the converter. Passing an instance of the
 * converter to the decorator allows for options to be passed to the converter.
 * ```typescript
 *  @Converter(new EnumerationConverter(IdentifierType))
 *  export class IdentifierType extends Enumeration {
 *      ...
 *  }
 * ```
 *
 * The example below specifies the property converter on the properties of the target class.
 * ```typescript
 *  @Embeddable(Rectangle)
 *  export class Rectangle {
 *
 *     @Converter(PointConverter)
 *     topLeft: Point;
 *
 *     @Converter(PointConverter)
 *     bottomRight: Point;
 *  }
 * ```
 */
export declare function Converter(converter: string | PropertyConverter | ParameterlessConstructor<PropertyConverter>): ClassDecorator & PropertyDecorator;
/**
 * Specifies the IdentityGenerator to use for a class.
 */
export declare function Identity(identity: IdentityGenerator | ParameterlessConstructor<IdentityGenerator>): ClassDecorator;
/**
 * Specifies the name of the collection used to hold the entity.
 *
 * If a name for the collection is not specified using the Collection decorator, an entity is mapped to a collection in
 * MongoDB based on the name of the class and the [[collectionNamingStrategy]] in the [[Configuration]]. The default
 * naming strategy is [[CamelCase]].
 *
 * ### Example
 *
 * ```typescript
 *  @Collection("people")
 *  @Entity()
 *  export class Person {
 *     ...
 *  }
 * ```
 */
export declare function Collection(name: string): ClassDecorator;
/**
 * Describes the collection used to hold the entity.
 *
 * If a name for the collection is not specified using the Collection decorator, an entity is mapped to a collection in
 * MongoDB based on the name of the class and the [[collectionNamingStrategy]] in the [[Configuration]]. The default
 * naming strategy is [[CamelCase]].
 *
 * ### Example
 *
 * ```typescript
 *  @Collection({ name: "logs", db: "dbname", options: { capped: true })
 *  @Entity()
 *  export class Log {
 *     ...
 *  }
 * ```
 */
export declare function Collection(description?: CollectionDescription): ClassDecorator;
/**
 * Specifies that a class is immutable. Can be used on Entity or Embeddable types. When specified on an Entity, the Entity is excluded from
 * dirty checking. When specified on an Embeddable, the original document for the Embeddable is cached and used for serialization.
 *
 * ### Example
 *
 * ```typescript
 *  @Embeddable()
 *  @Immutable()
 *  export class Name {
 *
 *      get first(): string {
 *          return this._first;
 *      }
 *
 *      get last(): string {
 *          return this._last;
 *      }
 *
 *      @Field()
 *      private _last: string;
 *
 *      @Field()
 *      private _first: string;
 *
 *      constructor(last: string, first: string) {
 *          this._last = last;
 *          this._first = first;
 *      }
 *  }
 * ```
 */
export declare function Immutable(): ClassDecorator;
/**
 * Specifies a database index should be generated on the collection that holds this entity.
 *
 * This is the required method of defining indexes when compound keys are needed.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  @Index({ keys: [['name', 1], ['age', 1]] })
 *  export class Person {
 *
 *      @Field()
 *      name: string;
 *
 *      @Field()
 *      age: number;
 *      ...
 *  }
 * ```
 */
export declare function Index(description: ClassIndexDescription): ClassDecorator;
/**
 * Specifies a database index should be generated for the specified field on the collection holds this entity.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Person {
 *
 *      @Index()
 *      name: string;
 *      ...
 *  }
 * ```
 */
export declare function Index(description?: PropertyIndexDescription): PropertyDecorator;
/**
 * Specifies the name of the field used to hold the entity version for optimistic locking.
 *
 * If the version field is not specified, `__v` is used.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  @VersionField("version")
 *  export class Person {
 *      ...
 *  }
 * ```
 */
export declare function VersionField(name: string): ClassDecorator;
/**
 * Specifies if optimistic locking should be used or not.
 *
 * Optimistic locking is enabled by default. A value of `false` disables optimistic locking.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  @Versioned(false)
 *  export class Person {
 *      ...
 *  }
 * ```
 */
export declare function Versioned(enabled?: boolean): ClassDecorator;
/**
 * Specifies the type of change tracking to use for an entity.
 *
 * See [[ChangeTrackingType]] for more information on the types of change tracking that are available.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  @ChangeTracking(ChangeTrackingType.DeferredImplicit)
 *  export class Person {
 *      ...
 *  }
 * ```
 */
export declare function ChangeTracking(type: ChangeTrackingType): ClassDecorator;
/**
 * Specifies the name of the field used for the class inheritance discriminator.
 *
 * If the discriminator field is not specified, a value of `__t` is used.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  @DiscriminatorField("type")
 *  export class Person {
 *      ...
 *  }
 * ```
 */
export declare function DiscriminatorField(name: string): ClassDecorator;
/**
 * Specifies the value to use for the discriminator for a class.
 *
 * If the discriminator value is not specified, the discriminator value for a class is determined using the
 * [[discriminatorNamingStrategy]] on the [[Configuration]]. By default, the name of the class is used.
 *
 * ### Example
 *
 *
 * ```typescript
 *  @Entity()
 *  class Party {
 *     ...
 *  }

 *  @Entity()
 *  @DiscriminatorValue("P")
 *  class Person extends Party {
 *     ...
 *  }
 *
 *  @Entity()
 *  @DiscriminatorValue("O")
 *  class Organization extends Party {
 *     ...
 *  }
 * ```
 */
export declare function DiscriminatorValue(value: string): ClassDecorator;
/**
 * Specifies the name of the field that should be used to serialize a property on an entity or embeddable class.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Person {
 *
 *      @Field("n")
 *      name: string;
 *      ...
 *  }
 * ```
 */
export declare function Field(name?: string): PropertyDecorator;
/**
 * Describes the field that should be used to serialize a property on an entity or embeddable class.
 *
 * Setting a value for `nullable` in the field description indicates whether or not `null` values should be saved to the database. If not
 * specified, the value in the [[Configuration]] is used. If `null` values are not allowed, `null` values are treated the same as
 * `undefined` values and removed from the serialized document.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Person {
 *
 *      @Field({ nullable: true })
 *      name: string;
 *      ...
 *  }
 * ```
 */
export declare function Field(description: FieldDescription): PropertyDecorator;
/**
 * Indicates that a property is a reference to the parent of an embeddable class.
 *
 * The reference to the parent is automatically populated when the document is read from the database and the object graph is built. The
 * value of the property is not saved to the database.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Person {
 *
 *      @ElementType(Address)
 *      addresses: Address[];
 *      ...
 *  }
 *
 *  @Embeddable()
 *  export class Address {
 *
 *      @Parent()
 *      resident: Person;
 *      ...
 *  }
 * ```
 */
export declare function Parent(): PropertyDecorator;
/**
 * Specifies that an enum value should be serialized as a string.
 *
 * By default enums are serialized as numbers. To serialize an enum as a string, add the Enumerated decorator to a
 * property, passing in the enum. Note that this cannot be used with `const` enums.
 *
 * ### Example
 *
 * ```typescript
 *  export enum TaskStatus {
 *
 *      Pending,
 *      Completed,
 *      Archived
 *  }
 *
 *  @Entity()
 *  export class Task {
 *
 *      @Enumerated(TaskStatus)
 *      status: TaskStatus;
 *      ...
 *  }
 * ```
 */
export declare function Enumerated(members: Object): PropertyDecorator;
/**
 * Specifies that a property is the inverse side of a entity reference.
 *
 * ### Example
 *
 * In the example below, the reference is stored on the `patient` property of the `Admission` entity.
 *
 * ```typescript
 * @Entity()
 * export class Patient {
 *
 *     @InverseOf("patient")
 *     @ElementType(Admission)
 *     admissions: Admission[];
 *     ...
 * }
 *
 * @Entity()
 * export class Admission {
 *
 *     @Field()
 *     patient: Patient;
 *     ...
 * }
 *
 * ...
 * session.fetch(patient.admissions, (err, admissions) => {
 *      ...
 * });
 * ```
 *
 * In the example below, the references are stored on the `admissions` property of the `Patient` entity.
 *
 * ```typescript
 * @Entity()
 * export class Patient {
 *
 *     @ElementType(Admission)
 *     admissions: Admission[];
 *     ...
 * }
 *
 * @Entity()
 * export class Admission {
 *
 *     @InverseOf("admissions")
 *     patient: Patient;
 *     ...
 * }
 *
 * ...
 * session.fetch(admission.patient, (err, patient) => {
 *      ...
 * });
 * ```
 */
export declare function InverseOf(propertyName: string): PropertyDecorator;
/**
 * Specifies which operations should cascade to a property on an entity or embeddable. The type of the property must be
 * an entity. See [[CascadeFlags]] for more information on the available cascade options.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Task {
 *
 *      @Cascade(CascadeFlags.Save | CascadeFlags.Remove)
 *      owner: Person;
 *  }
 * ```
 */
export declare function Cascade(flags: CascadeFlags): PropertyDecorator;
/**
 * ### FetchType.Eager
 *
 * By default entity references are not loaded and must be fetched using Session#fetch or similar. If a FetchType of Eager is specified on
 * an entity reference then that reference is automatically fetched when the entity is loaded.
 *
 * #### Notes
 * * This works on entity reference in Embeddable objects as well.
 * * It is generally preferable to fetch references as needed.
 * * A FetchType of Eager on a property that is not an entity reference has no effect.
 *
 * #### Example
 * ```typescript
 *  @Entity()
 *  export class Task {
 *
 *      @Fetch(FetchType.Eager)
 *      owner: Person;
 *  }
 * ```
 *
 * ### FetchType.Lazy
 *
 * When an entity is loaded, all fields for that entity are retrieved from the database. Specifying a FetchType of Lazy for a field causes
 * that field to not be retrieved from the database when the entity is loaded. The field is only loaded by calling Session#fetch and
 * indicating which field to load.
 *
 * #### Notes
 * * Useful for properties that contain large amounts of data, such as images, that are not always needed.
 * * A FetchType of Lazy on a property in an Embeddable objects is ignored. All properties in an embeddable object are always loaded from the database.
 * * It is generally not advisable to use a FetchType of Lazy on a property that is an entity reference.
 *
 * #### Example
 * ```typescript
 *  @Entity()
 *  export class Person {
 *
 *      @Fetch(FetchType.Lazy)
 *      image: Buffer;
 *  }
 * ```
 */
export declare function Fetch(type: FetchType): PropertyDecorator;
/**
 * Specifies the type of a property.
 *
 * It is generally not necessary to explicitly indicate the type of a property.
 * However, when a property is an embeddable or a reference to an entity, sometimes the type of the property cannot be
 * determined because of circular references of `import` statements. In this case the Type decorator should be used
 * with the name of the type.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Task {
 *
 *      @Type("Person")
 *      owner: Person;
 *  }
 * ```
 */
export declare function Type(target: Constructor<any> | string): PropertyDecorator;
/**
 * Specified the type of an array element.
 *
 * TypeScript does not provide the type of an array element, so the type of the array element must be indicate with the
 * ElementType decorator.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class Organization {
 *
 *      @ElementType(Address)
 *      addresses: Address[];
 *  }
 * ```
 */
export declare function ElementType(target: Constructor<any> | string): PropertyDecorator;
/**
 * @hidden
 */
export declare function MapKey(propertyName: string): PropertyDecorator;
/**
 * Specifies that a property should not be persisted.
 *
 * Properties are mapped to persistent document fields on an opt-in basis. *All properties that are decorated are
 * mapped.* However, if you wish to prevent a decorated property from being mapped, decorate that property with the
 * Transient decorator as demonstrated below.
 *
 * ### Example
 *
 * ```typescript
 *  @Entity()
 *  export class User {
 *
 *      @Transient()
 *      @SomeOtherDecorator()
 *      private _something: string;
 *  }
 * ```
 */
export declare function Transient(): PropertyDecorator;
