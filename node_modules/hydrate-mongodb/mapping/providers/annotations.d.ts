import { PropertyConverter, FlushPriority, FetchType } from "../mappingModel";
import { CollectionOptions } from "../collectionOptions";
import { IndexOptions } from "../indexOptions";
import { ChangeTrackingType } from "../mappingModel";
import { CascadeFlags } from "../mappingModel";
import { Constructor, ParameterlessConstructor } from "../../index";
import { MappingModel } from "../mappingModel";
import { MappingBuilderContext } from "./mappingBuilderContext";
import { MappingBuilder } from "./mappingBuilder";
import { Type, Property, Method } from "reflect-helper";
import { IdentityGenerator } from "../../config/configuration";
/**
 * Indicates the order in which annotations are processed. Annotations with a higher priority are processed first.
 * @hidden
 */
export declare enum AnnotationPriority {
    High = 100,
    Medium = 50,
    Low = 0,
}
/**
 * @hidden
 */
export declare class Annotation {
}
/**
 * @hidden
 */
export interface ClassAnnotation {
    /**
     * Indicates if the annotation should be inherited from a mapped superclass. Default is false.
     */
    inherited?: boolean;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, annotation: Annotation): void;
}
/**
 * @hidden
 */
export interface PropertyAnnotation {
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: Annotation): void;
}
/**
 * @hidden
 */
export interface MethodAnnotation {
    processMethodAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, method: Method, annotation: Annotation): void;
}
/**
 * @hidden
 */
export interface MappingBuilderAnnotation {
    createBuilder(context: MappingBuilderContext, type: Type): MappingBuilder;
}
/**
 * @hidden
 */
export interface TargetClassAnnotation {
    target: Constructor<any> | string;
}
/**
 * @hidden
 */
export declare class EntityAnnotation extends Annotation implements MappingBuilderAnnotation {
    createBuilder(context: MappingBuilderContext, type: Type): MappingBuilder;
    toString(): string;
}
/**
 * @hidden
 */
export declare class EmbeddableAnnotation extends Annotation implements MappingBuilderAnnotation {
    createBuilder(context: MappingBuilderContext, type: Type): MappingBuilder;
    toString(): string;
}
/**
 * @hidden
 */
export declare class ConverterAnnotation extends Annotation implements MappingBuilderAnnotation {
    converter: PropertyConverter;
    converterCtr: ParameterlessConstructor<PropertyConverter>;
    converterName: string;
    /**
     * Constructs a ConverterAnnotation object.
     * @param converter The name, instance, or constructor of the PropertyConverter to apply to the property or class.
     */
    constructor(converter: string | PropertyConverter | ParameterlessConstructor<PropertyConverter>);
    toString(): string;
    createBuilder(context: MappingBuilderContext, type: Type): MappingBuilder;
    createMapping(context: MappingBuilderContext): MappingModel.Mapping;
}
/**
 * @hidden
 */
export declare class CollectionAnnotation extends Annotation implements ClassAnnotation {
    /**
     * The name of the collection to use.
     */
    name: string;
    /**
     * The order in which collections are flushed to the database. Higher priority collections are flushed first.
     */
    flushPriority: FlushPriority;
    /**
     * The name of the database to use.
     */
    db: string;
    /**
     * Collection options to pass to driver.
     */
    options: CollectionOptions;
    constructor(name: string);
    constructor(description?: CollectionDescription);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: CollectionAnnotation): void;
}
export interface CollectionDescription {
    flushPriority?: FlushPriority;
    name?: string;
    db?: string;
    options?: CollectionOptions;
}
/**
 * @hidden
 */
export declare class IndexAnnotation extends Annotation implements ClassAnnotation, PropertyAnnotation {
    /**
     * The index keys as an array of tuples [name, 1|-1] if the annotation is specified on a class.
     */
    keys: [string, number | string][];
    /**
     * The order of the index if annotation is specified on a property.
     */
    order: number;
    /**
     * Index options to pass to the driver.
     */
    options: IndexOptions;
    /**
     * Indicates annotation is inherited from a mapped superclass.
     */
    inherited: boolean;
    constructor(args: ClassIndexDescription);
    constructor(args?: PropertyIndexDescription);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: IndexAnnotation): void;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, property: MappingModel.Property, symbol: Property, annotation: IndexAnnotation): void;
    private _addIndex(context, mapping, value);
}
export interface ClassIndexDescription {
    keys: [string, number | string][];
    options?: IndexOptions;
}
export interface PropertyIndexDescription {
    order?: number | string;
    options?: IndexOptions;
}
/**
 * @hidden
 */
export declare class VersionFieldAnnotation extends Annotation implements ClassAnnotation {
    name: string;
    /**
     * Constructs a VersionFieldAnnotation object.
     * @param name The name of the document field to use for versioning.
     */
    constructor(name: string);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: VersionFieldAnnotation): void;
}
/**
 * @hidden
 */
export declare class VersionedAnnotation extends Annotation implements ClassAnnotation {
    enabled: boolean;
    /**
     * Constructs a VersionedAnnotation object.
     * @param enabled Indicates if versioning is enabled. Default is true.
     */
    constructor(enabled?: boolean);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: VersionedAnnotation): void;
}
/**
 * @hidden
 */
export declare class ChangeTrackingAnnotation extends Annotation implements ClassAnnotation {
    type: ChangeTrackingType;
    constructor(type: ChangeTrackingType);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: ChangeTrackingAnnotation): void;
}
/**
 * @hidden
 */
export declare class IdentityAnnotation extends Annotation implements ClassAnnotation {
    identity: IdentityGenerator;
    identityCtr: ParameterlessConstructor<IdentityGenerator>;
    /**
     * Constructs a IdentityAnnotation object.
     * @param identity The instance or constructor of the IdentityGenerator to apply to the class.
     */
    constructor(identity: IdentityGenerator | ParameterlessConstructor<IdentityGenerator>);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.EntityMapping, annotation: ChangeTrackingAnnotation): void;
}
/**
 * @hidden
 */
export declare class DiscriminatorFieldAnnotation extends Annotation implements ClassAnnotation {
    name: string;
    constructor(name: string);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.ClassMapping, annotation: DiscriminatorFieldAnnotation): void;
}
/**
 * @hidden
 */
export declare class ImmutableAnnotation extends Annotation implements ClassAnnotation {
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.ClassMapping, annotation: ImmutableAnnotation): void;
}
/**
 * @hidden
 */
export declare class DiscriminatorValueAnnotation extends Annotation implements ClassAnnotation {
    value: string;
    constructor(value: string);
    toString(): string;
    processClassAnnotation(context: MappingBuilderContext, mapping: MappingModel.ClassMapping, annotation: DiscriminatorValueAnnotation): void;
}
/**
 * @hidden
 */
export declare class InverseOfAnnotation extends Annotation implements PropertyAnnotation {
    propertyName: string;
    constructor(propertyName: string);
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: InverseOfAnnotation): void;
}
/**
 * @hidden
 */
export declare class CascadeAnnotation extends Annotation implements PropertyAnnotation {
    flags: CascadeFlags;
    constructor(flags: CascadeFlags);
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: CascadeAnnotation): void;
}
/**
 * @hidden
 */
export declare class FetchAnnotation extends Annotation implements PropertyAnnotation {
    type: FetchType;
    constructor(type: FetchType);
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: FetchAnnotation): void;
}
/**
 * @hidden
 */
export declare class TypeAnnotation extends Annotation implements TargetClassAnnotation {
    target: Constructor<any> | string;
    constructor(target: Constructor<any> | string);
    toString(): string;
}
/**
 * @hidden
 */
export declare class ElementTypeAnnotation extends Annotation implements TargetClassAnnotation {
    target: Constructor<any> | string;
    constructor(target: Constructor<any> | string);
    toString(): string;
}
/**
 * @hidden
 */
export declare class MapKeyAnnotation extends Annotation {
    propertyName: string;
    constructor(propertyName: string);
    toString(): string;
}
/**
 * @hidden
 */
export declare class FieldAnnotation extends Annotation implements PropertyAnnotation {
    name: string;
    nullable: boolean;
    readable: boolean;
    constructor(name?: string);
    constructor(args: FieldDescription);
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: FieldAnnotation): void;
}
/**
 * @hidden
 */
export declare class ParentAnnotation extends Annotation implements PropertyAnnotation {
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: FieldAnnotation): void;
}
export interface FieldDescription {
    /**
     * The name of the database document field.
     */
    name?: string;
    /**
     * Indicates if null values are supported. If false then null values are not written to the database. Default is false.
     */
    nullable?: boolean;
    /**
     * Indicates if the database document field should be read. Default is true. If set the `false` the database document field may still
     * be written to but the field value is not read when deserializing the document from the database. This is useful if your entity has
     * an accessor with a value calculated from other fields in the class that you want to store to the database for queries.
     */
    readable?: boolean;
}
/**
 * @hidden
 */
export declare class EnumeratedAnnotation {
    members: Object;
    constructor(members: Object);
    toString(): string;
}
/**
 * @hidden
 */
export declare class TransientAnnotation implements PropertyAnnotation {
    toString(): string;
    processPropertyAnnotation(context: MappingBuilderContext, mapping: MappingModel.ObjectMapping, property: MappingModel.Property, symbol: Property, annotation: Annotation): void;
}
