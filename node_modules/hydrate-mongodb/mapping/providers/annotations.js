"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var mappingModel_1 = require("../mappingModel");
var mappingBuilder_1 = require("./mappingBuilder");
var entityMappingBuilder_1 = require("./entityMappingBuilder");
var classMappingBuilder_1 = require("./classMappingBuilder");
/**
 * Indicates the order in which annotations are processed. Annotations with a higher priority are processed first.
 * @hidden
 */
var AnnotationPriority;
(function (AnnotationPriority) {
    AnnotationPriority[AnnotationPriority["High"] = 100] = "High";
    AnnotationPriority[AnnotationPriority["Medium"] = 50] = "Medium";
    AnnotationPriority[AnnotationPriority["Low"] = 0] = "Low";
})(AnnotationPriority = exports.AnnotationPriority || (exports.AnnotationPriority = {}));
/**
 * @hidden
 */
var Annotation = /** @class */ (function () {
    function Annotation() {
    }
    return Annotation;
}());
exports.Annotation = Annotation;
/**
 * @hidden
 */
var EntityAnnotation = /** @class */ (function (_super) {
    __extends(EntityAnnotation, _super);
    function EntityAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EntityAnnotation.prototype.createBuilder = function (context, type) {
        var parentMapping = getParentMapping(context, type);
        if (parentMapping && (parentMapping.flags & 1024 /* Entity */) == 0) {
            context.addError("Parent of mapping for '" + type.name + "' must be an entity mapping.");
            return;
        }
        return new entityMappingBuilder_1.EntityMappingBuilder(context, type, mappingModel_1.MappingModel.createEntityMapping((parentMapping)));
    };
    EntityAnnotation.prototype.toString = function () {
        return "@Entity";
    };
    return EntityAnnotation;
}(Annotation));
exports.EntityAnnotation = EntityAnnotation;
/**
 * @hidden
 */
var EmbeddableAnnotation = /** @class */ (function (_super) {
    __extends(EmbeddableAnnotation, _super);
    function EmbeddableAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmbeddableAnnotation.prototype.createBuilder = function (context, type) {
        var parentMapping = getParentMapping(context, type);
        if (parentMapping && (parentMapping.flags & 2048 /* Embeddable */) == 0) {
            context.addError("Parent of mapping for '" + type.name + "' must be an embeddable mapping.");
            return;
        }
        return new classMappingBuilder_1.ClassMappingBuilder(context, type, mappingModel_1.MappingModel.createClassMapping(parentMapping));
    };
    EmbeddableAnnotation.prototype.toString = function () {
        return "@Embeddable";
    };
    return EmbeddableAnnotation;
}(Annotation));
exports.EmbeddableAnnotation = EmbeddableAnnotation;
/**
 * @hidden
 */
var ConverterAnnotation = /** @class */ (function (_super) {
    __extends(ConverterAnnotation, _super);
    /**
     * Constructs a ConverterAnnotation object.
     * @param converter The name, instance, or constructor of the PropertyConverter to apply to the property or class.
     */
    function ConverterAnnotation(converter) {
        var _this = _super.call(this) || this;
        if (typeof converter === "string") {
            _this.converterName = converter;
        }
        else if (typeof converter === "function") {
            _this.converterCtr = converter;
        }
        else {
            _this.converter = converter;
        }
        return _this;
    }
    ConverterAnnotation.prototype.toString = function () {
        return "@Converter";
    };
    ConverterAnnotation.prototype.createBuilder = function (context, type) {
        return new mappingBuilder_1.MappingBuilder(context, type, this.createMapping(context));
    };
    ConverterAnnotation.prototype.createMapping = function (context) {
        if (this.converter) {
            return mappingModel_1.MappingModel.createConverterMapping(this.converter);
        }
        if (this.converterCtr) {
            return mappingModel_1.MappingModel.createConverterMapping(new this.converterCtr());
        }
        if (!this.converterName) {
            context.addError("A convert instance, constructor, or name must be specified.");
            return;
        }
        var converter = context.config.propertyConverters && context.config.propertyConverters[this.converterName];
        if (!converter) {
            context.addError("Unknown converter '" + this.converterName + "'. Make sure to add your converter to propertyConverters in the configuration.");
            return;
        }
        return mappingModel_1.MappingModel.createConverterMapping(converter);
    };
    return ConverterAnnotation;
}(Annotation));
exports.ConverterAnnotation = ConverterAnnotation;
/**
 * @hidden
 */
var CollectionAnnotation = /** @class */ (function (_super) {
    __extends(CollectionAnnotation, _super);
    function CollectionAnnotation(nameOrDescription) {
        var _this = _super.call(this) || this;
        if (typeof nameOrDescription === "string") {
            _this.name = nameOrDescription;
        }
        if (typeof nameOrDescription === "object") {
            _this.name = nameOrDescription.name;
            _this.flushPriority = nameOrDescription.flushPriority;
            _this.db = nameOrDescription.db;
            _this.options = nameOrDescription.options;
        }
        return _this;
    }
    CollectionAnnotation.prototype.toString = function () {
        return "@Collection";
    };
    CollectionAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootEntityMapping(mapping)) {
            if (annotation.name) {
                mapping.collectionName = annotation.name;
            }
            mapping.collectionOptions = annotation.options;
            // TODO: validate options
            if (annotation.db) {
                mapping.databaseName = annotation.db;
            }
            if (annotation.flushPriority != null) {
                mapping.flushPriority = annotation.flushPriority;
            }
        }
    };
    return CollectionAnnotation;
}(Annotation));
exports.CollectionAnnotation = CollectionAnnotation;
/**
 * @hidden
 */
var IndexAnnotation = /** @class */ (function (_super) {
    __extends(IndexAnnotation, _super);
    function IndexAnnotation(args) {
        var _this = _super.call(this) || this;
        /**
         * Indicates annotation is inherited from a mapped superclass.
         */
        _this.inherited = true;
        if (args) {
            _this.keys = args.keys;
            _this.order = args.order;
            _this.options = args.options;
        }
        return _this;
    }
    IndexAnnotation.prototype.toString = function () {
        return "@Index";
    };
    IndexAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertEntityMapping(mapping)) {
            this._addIndex(context, mapping, annotation);
        }
    };
    IndexAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        if (context.assertEntityMapping(mapping)) {
            this._addIndex(context, mapping, {
                keys: [[property.name, annotation.order || 1]],
                options: annotation.options
            });
        }
    };
    IndexAnnotation.prototype._addIndex = function (context, mapping, value) {
        // TODO: allow indexes in embedded types and map to containing root type
        if (context.assertEntityMapping(mapping)) {
            if (!Array.isArray(value.keys) || value.keys.length == 0) {
                context.addError("Missing or invalid property 'keys'.");
                return;
            }
            for (var i = 0; i < value.keys.length; i++) {
                var key = value.keys[i];
                if (!Array.isArray(key) || key.length != 2 || typeof key[0] !== "string") {
                    context.addError("Index key " + i + " is invalid. Key must be a tuple [path, order].");
                    return;
                }
                var order = value.keys[i][1];
                if (order != 1 && order != -1 && order != 'text') {
                    context.addError("Valid values for index order are 1, -1, or 'text'.");
                    return;
                }
            }
            // TODO: validate index options
            mapping.addIndex(value);
        }
    };
    return IndexAnnotation;
}(Annotation));
exports.IndexAnnotation = IndexAnnotation;
/**
 * @hidden
 */
var VersionFieldAnnotation = /** @class */ (function (_super) {
    __extends(VersionFieldAnnotation, _super);
    /**
     * Constructs a VersionFieldAnnotation object.
     * @param name The name of the document field to use for versioning.
     */
    function VersionFieldAnnotation(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        return _this;
    }
    VersionFieldAnnotation.prototype.toString = function () {
        return "@VersionField";
    };
    VersionFieldAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootEntityMapping(mapping)) {
            mapping.versionField = annotation.name;
            mapping.versioned = true;
        }
    };
    return VersionFieldAnnotation;
}(Annotation));
exports.VersionFieldAnnotation = VersionFieldAnnotation;
/**
 * @hidden
 */
var VersionedAnnotation = /** @class */ (function (_super) {
    __extends(VersionedAnnotation, _super);
    /**
     * Constructs a VersionedAnnotation object.
     * @param enabled Indicates if versioning is enabled. Default is true.
     */
    function VersionedAnnotation(enabled) {
        if (enabled === void 0) { enabled = true; }
        var _this = _super.call(this) || this;
        _this.enabled = enabled;
        return _this;
    }
    VersionedAnnotation.prototype.toString = function () {
        return "@Versioned";
    };
    VersionedAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootEntityMapping(mapping)) {
            mapping.versioned = annotation.enabled;
        }
    };
    return VersionedAnnotation;
}(Annotation));
exports.VersionedAnnotation = VersionedAnnotation;
/**
 * @hidden
 */
var ChangeTrackingAnnotation = /** @class */ (function (_super) {
    __extends(ChangeTrackingAnnotation, _super);
    function ChangeTrackingAnnotation(type) {
        var _this = _super.call(this) || this;
        _this.type = type;
        return _this;
    }
    ChangeTrackingAnnotation.prototype.toString = function () {
        return "@ChangeTracking";
    };
    ChangeTrackingAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootEntityMapping(mapping)) {
            if ((mapping.flags & 131072 /* Immutable */) != 0) {
                context.addError("Change tracking cannot be set on immutable entity.");
                return;
            }
            mapping.changeTracking = annotation.type;
        }
    };
    return ChangeTrackingAnnotation;
}(Annotation));
exports.ChangeTrackingAnnotation = ChangeTrackingAnnotation;
/**
 * @hidden
 */
var IdentityAnnotation = /** @class */ (function (_super) {
    __extends(IdentityAnnotation, _super);
    /**
     * Constructs a IdentityAnnotation object.
     * @param identity The instance or constructor of the IdentityGenerator to apply to the class.
     */
    function IdentityAnnotation(identity) {
        var _this = _super.call(this) || this;
        if (typeof identity === "function") {
            _this.identityCtr = identity;
        }
        else {
            _this.identity = identity;
        }
        return _this;
    }
    IdentityAnnotation.prototype.toString = function () {
        return "@Identity";
    };
    IdentityAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootEntityMapping(mapping)) {
            var identity;
            if (this.identity) {
                identity = this.identity;
            }
            else if (this.identityCtr) {
                identity = new this.identityCtr();
            }
            if (!identity) {
                context.addError("An identity generator instance or constructor must be specified.");
                return;
            }
            mapping.identity = identity;
        }
    };
    return IdentityAnnotation;
}(Annotation));
exports.IdentityAnnotation = IdentityAnnotation;
/**
 * @hidden
 */
var DiscriminatorFieldAnnotation = /** @class */ (function (_super) {
    __extends(DiscriminatorFieldAnnotation, _super);
    function DiscriminatorFieldAnnotation(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        return _this;
    }
    DiscriminatorFieldAnnotation.prototype.toString = function () {
        return "@DiscriminatorField";
    };
    DiscriminatorFieldAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertRootClassMapping(mapping)) {
            if (!annotation.name) {
                context.addError("Missing discriminator field name.");
                return;
            }
            mapping.discriminatorField = annotation.name;
        }
    };
    return DiscriminatorFieldAnnotation;
}(Annotation));
exports.DiscriminatorFieldAnnotation = DiscriminatorFieldAnnotation;
/**
 * @hidden
 */
var ImmutableAnnotation = /** @class */ (function (_super) {
    __extends(ImmutableAnnotation, _super);
    function ImmutableAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImmutableAnnotation.prototype.toString = function () {
        return "@Immutable";
    };
    ImmutableAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertClassMapping(mapping)) {
            mapping.flags |= 131072 /* Immutable */;
            // if this is a root entity then set the change tracking to 'None'
            if ((mapping.flags & 1024 /* Entity */) != 0
                && (mapping.flags & 4096 /* InheritanceRoot */) != 0) {
                var entityMapping = mapping;
                if (entityMapping.changeTracking != null) {
                    context.addError("Change tracking cannot be set on immutable entity.");
                    return;
                }
                entityMapping.changeTracking = 0 /* None */;
                // no reason to version an entity that isn't going to change.
                entityMapping.versioned = false;
            }
        }
    };
    return ImmutableAnnotation;
}(Annotation));
exports.ImmutableAnnotation = ImmutableAnnotation;
/**
 * @hidden
 */
var DiscriminatorValueAnnotation = /** @class */ (function (_super) {
    __extends(DiscriminatorValueAnnotation, _super);
    function DiscriminatorValueAnnotation(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        return _this;
    }
    DiscriminatorValueAnnotation.prototype.toString = function () {
        return "@DiscriminatorValue";
    };
    DiscriminatorValueAnnotation.prototype.processClassAnnotation = function (context, mapping, annotation) {
        if (context.assertClassMapping(mapping)) {
            if (!annotation.value) {
                context.addError("Missing discriminator value.");
                return;
            }
            try {
                mapping.setDiscriminatorValue(annotation.value);
            }
            catch (err) {
                context.addError(err.message);
            }
        }
    };
    return DiscriminatorValueAnnotation;
}(Annotation));
exports.DiscriminatorValueAnnotation = DiscriminatorValueAnnotation;
/**
 * @hidden
 */
var InverseOfAnnotation = /** @class */ (function (_super) {
    __extends(InverseOfAnnotation, _super);
    function InverseOfAnnotation(propertyName) {
        var _this = _super.call(this) || this;
        _this.propertyName = propertyName;
        return _this;
    }
    InverseOfAnnotation.prototype.toString = function () {
        return "@InverseOf";
    };
    InverseOfAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        // TODO: validate inverse relationship
        property.inverseOf = annotation.propertyName;
        property.setFlags(64 /* InverseSide */);
    };
    return InverseOfAnnotation;
}(Annotation));
exports.InverseOfAnnotation = InverseOfAnnotation;
/**
 * @hidden
 */
var CascadeAnnotation = /** @class */ (function (_super) {
    __extends(CascadeAnnotation, _super);
    function CascadeAnnotation(flags) {
        var _this = _super.call(this) || this;
        _this.flags = flags;
        return _this;
    }
    CascadeAnnotation.prototype.toString = function () {
        return "@Cascade";
    };
    CascadeAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        property.setFlags(annotation.flags & 62 /* CascadeAll */);
    };
    return CascadeAnnotation;
}(Annotation));
exports.CascadeAnnotation = CascadeAnnotation;
/**
 * @hidden
 */
var FetchAnnotation = /** @class */ (function (_super) {
    __extends(FetchAnnotation, _super);
    function FetchAnnotation(type) {
        var _this = _super.call(this) || this;
        _this.type = type;
        return _this;
    }
    FetchAnnotation.prototype.toString = function () {
        return "@Fetch";
    };
    FetchAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        property.setFlags(annotation.type & (1024 /* FetchEager */ | 2048 /* FetchLazy */));
    };
    return FetchAnnotation;
}(Annotation));
exports.FetchAnnotation = FetchAnnotation;
/**
 * @hidden
 */
var TypeAnnotation = /** @class */ (function (_super) {
    __extends(TypeAnnotation, _super);
    function TypeAnnotation(target) {
        var _this = _super.call(this) || this;
        _this.target = target;
        return _this;
    }
    TypeAnnotation.prototype.toString = function () {
        return "@Type";
    };
    return TypeAnnotation;
}(Annotation));
exports.TypeAnnotation = TypeAnnotation;
/**
 * @hidden
 */
var ElementTypeAnnotation = /** @class */ (function (_super) {
    __extends(ElementTypeAnnotation, _super);
    function ElementTypeAnnotation(target) {
        var _this = _super.call(this) || this;
        _this.target = target;
        return _this;
    }
    ElementTypeAnnotation.prototype.toString = function () {
        return "@ElementType";
    };
    return ElementTypeAnnotation;
}(Annotation));
exports.ElementTypeAnnotation = ElementTypeAnnotation;
/**
 * @hidden
 */
var MapKeyAnnotation = /** @class */ (function (_super) {
    __extends(MapKeyAnnotation, _super);
    function MapKeyAnnotation(propertyName) {
        var _this = _super.call(this) || this;
        _this.propertyName = propertyName;
        return _this;
    }
    MapKeyAnnotation.prototype.toString = function () {
        return "@MapKey";
    };
    return MapKeyAnnotation;
}(Annotation));
exports.MapKeyAnnotation = MapKeyAnnotation;
/**
 * @hidden
 */
var FieldAnnotation = /** @class */ (function (_super) {
    __extends(FieldAnnotation, _super);
    function FieldAnnotation(args) {
        var _this = _super.call(this) || this;
        if (args) {
            if (typeof args === "string") {
                _this.name = args;
            }
            else {
                _this.name = args.name;
                _this.nullable = args.nullable;
                _this.readable = args.readable;
            }
        }
        return _this;
    }
    FieldAnnotation.prototype.toString = function () {
        return "@Field";
    };
    FieldAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        if (annotation.name) {
            property.field = annotation.name;
        }
        if (annotation.nullable !== undefined) {
            property.nullable = annotation.nullable;
        }
        if (annotation.readable === false) {
            property.setFlags(512 /* WriteOnly */);
        }
    };
    return FieldAnnotation;
}(Annotation));
exports.FieldAnnotation = FieldAnnotation;
/**
 * @hidden
 */
var ParentAnnotation = /** @class */ (function (_super) {
    __extends(ParentAnnotation, _super);
    function ParentAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ParentAnnotation.prototype.toString = function () {
        return "@Parent";
    };
    ParentAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        if (context.assertEmbeddableMapping(mapping)) {
            property.setFlags(4096 /* Parent */ | 1 /* Ignored */);
        }
    };
    return ParentAnnotation;
}(Annotation));
exports.ParentAnnotation = ParentAnnotation;
/**
 * @hidden
 */
var EnumeratedAnnotation = /** @class */ (function () {
    function EnumeratedAnnotation(members) {
        this.members = members;
    }
    EnumeratedAnnotation.prototype.toString = function () {
        return "@Enumerated";
    };
    return EnumeratedAnnotation;
}());
exports.EnumeratedAnnotation = EnumeratedAnnotation;
/**
 * @hidden
 */
function getParentMapping(context, type) {
    var baseType = type.baseType;
    if (baseType) {
        var builder = context.getBuilder(baseType);
        if (builder) {
            return builder.mapping;
        }
    }
}
/**
 * @hidden
 */
var TransientAnnotation = /** @class */ (function () {
    function TransientAnnotation() {
    }
    TransientAnnotation.prototype.toString = function () {
        return "@Transient";
    };
    TransientAnnotation.prototype.processPropertyAnnotation = function (context, mapping, property, symbol, annotation) {
        property.field = null;
        property.setFlags(1 /* Ignored */);
    };
    return TransientAnnotation;
}());
exports.TransientAnnotation = TransientAnnotation;
