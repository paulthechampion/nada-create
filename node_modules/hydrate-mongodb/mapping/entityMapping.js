"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var classMapping_1 = require("./classMapping");
var reference_1 = require("../reference");
var persistenceError_1 = require("../persistenceError");
/**
 * @hidden
 */
var EntityMapping = /** @class */ (function (_super) {
    __extends(EntityMapping, _super);
    function EntityMapping(baseClass) {
        var _this = _super.call(this, baseClass) || this;
        /**
         * The order in which collections are flushed to the database. Higher priority collections are flushed first.
         */
        _this.flushPriority = 50 /* Medium */;
        _this.flags &= ~2048 /* Embeddable */;
        _this.flags |= 1024 /* Entity */;
        return _this;
    }
    /**
     * Validates a property before adding it to the mapping. Returns any validation error messages or undefined if none.
     * @param property The property to validate.
     * @returns The error message.
     */
    EntityMapping.prototype.validateProperty = function (property) {
        if (property && property.name) {
            if (property.name == "_id") {
                return "The '_id' property on an entity class is automatically populated with the primary key and cannot be explicitly mapped.";
            }
            if (property.name == "id") {
                return "The 'id' property on an entity class is automatically populated with the string representation of the primary key " +
                    "and cannot be explicitly mapped.";
            }
        }
        return _super.prototype.validateProperty.call(this, property);
    };
    EntityMapping.prototype.setDocumentVersion = function (obj, version) {
        // TODO: escape versionField
        this.setDocumentVersion = (new Function("o", "v", "o['" + this.inheritanceRoot.versionField + "'] = v"));
        obj[this.inheritanceRoot.versionField] = version;
    };
    EntityMapping.prototype.getDocumentVersion = function (obj) {
        // TODO: escape versionField
        this.getDocumentVersion = (new Function("o", "return o['" + this.inheritanceRoot.versionField + "']"));
        return obj[this.inheritanceRoot.versionField];
    };
    EntityMapping.prototype.addIndex = function (index) {
        if (!this.indexes) {
            this.indexes = [];
        }
        this.indexes.push(index);
    };
    EntityMapping.prototype.refresh = function (context, entity, document) {
        var mapping = this.getMapping(context, document);
        if (mapping) {
            if (mapping != this) {
                // http://jsperf.com/change-proto-on-class
                // http://stackoverflow.com/questions/23807805/why-is-mutating-the-prototype-of-an-object-bad-for-performance
                context.addError("Refresh does not support changing instantiated class of entity.");
                return;
            }
            return this.readObject(context, entity, document, /* checkRemoved */ true);
        }
    };
    EntityMapping.prototype.read = function (context, value) {
        if (value == null)
            return null;
        var id;
        // if this is not the top level, the value should be the id
        if (context.path) {
            // TODO: handle DBRef
            id = value;
        }
        else {
            // otherwise, get the value from the document
            id = value["_id"];
            if (!id) {
                context.addError("Missing identifier.", "_id");
                return;
            }
        }
        // TODO: handle DBRef
        if (!this.inheritanceRoot.identity.validate(id)) {
            context.addError("'" + id.toString() + "' is not a valid identifier.", (context.path ? context.path + "." : "") + "_id");
            return;
        }
        // if this is not the top level
        if (context.path) {
            // TODO: confirm how we want to handle ObjectState.Removed.
            return context.session.getReferenceInternal(this, id);
        }
        var obj = _super.prototype.read.call(this, context, value);
        if (obj) {
            obj["_id"] = id;
            obj["id"] = id.toString();
        }
        return obj;
    };
    EntityMapping.prototype.write = function (context, value) {
        if (value == null)
            return null;
        var id;
        // Note that this.classConstructor could represent a base class since we are checking the id before looking up
        // the mapping for the current object in Class.write.
        // TODO: validate mapping that all classes inherit from inheritanceRoot or this ^ may not work
        // if the value is not an instance of the entity's constructor then it should be an identifier or DBRef
        // TODO: Use session.getId?
        // retrieve the id from the object
        if (!(id = value["_id"])) {
            context.addError("Missing identifier.", (context.path ? context.path + "." : "") + "_id");
            return;
        }
        if (!this.inheritanceRoot.identity.validate(id)) {
            context.addError("'" + id.toString() + "' is not a valid identifier.", (context.path ? context.path + "." : "") + "_id");
            return;
        }
        // if this is not the top level then just return a reference
        if (context.path) {
            // TODO: decide when to save reference as a DBRef
            return id;
        }
        var document = _super.prototype.write.call(this, context, value);
        if (document) {
            document["_id"] = id;
        }
        return document;
    };
    EntityMapping.prototype.watchEntity = function (entity, observer) {
        _super.prototype.watch.call(this, entity, observer, []);
    };
    EntityMapping.prototype.watch = function (value, observer, visited) {
        // Do nothing. Watch does not propagate to other entities.
    };
    EntityMapping.prototype.areDocumentsEqual = function (document1, document2) {
        return _super.prototype.areEqual.call(this, document1, document2);
    };
    EntityMapping.prototype.areEqual = function (documentValue1, documentValue2) {
        if (documentValue1 === documentValue2)
            return true;
        if (documentValue1 == null || documentValue2 == null)
            return false;
        var id1 = documentValue1["_id"] || documentValue1, id2 = documentValue2["_id"] || documentValue2;
        if (id1 == null || id2 == null) {
            return false;
        }
        return this.inheritanceRoot.identity.areEqual(id1, id2);
    };
    EntityMapping.prototype.walk = function (session, value, flags, entities, embedded, references) {
        if (!value || typeof value !== "object")
            return;
        if (reference_1.Reference.isReference(value)) {
            // TODO: handle DBRef
            var entity = session.getObject(value.id);
            if (entity) {
                value = entity;
            }
            else {
                if (flags & 16384 /* Dereference */) {
                    // store reference to resolve later
                    references.push(value);
                }
                return;
            }
        }
        if (entities.indexOf(value) !== -1)
            return;
        entities.push(value);
        // If this isn't the first entity, only continue if we have the WalkEntities flag
        if ((flags & 8192 /* WalkEntities */) == 0 && entities.length > 1)
            return;
        _super.prototype.walk.call(this, session, value, flags, entities, embedded, references);
    };
    EntityMapping.prototype.fetch = function (session, parentEntity, value, path, depth, callback) {
        var _this = this;
        if (!value || typeof value !== "object") {
            process.nextTick(function () { return callback(null, value); });
            return;
        }
        if (reference_1.Reference.isReference(value)) {
            // TODO: handle DBRef
            // We don't bother with the call to getObject here since fetch will call getObject. The reason we have the
            // separate call to getObject in 'walk' above is that walk only calls fetch if ProperFlags.Dereference is
            // passed in but should still include the object in the found entities if the object is managed.
            value.fetch(session, function (err, entity) {
                if (err)
                    return callback(err);
                _super.prototype.fetch.call(_this, session, entity, entity, path, depth, callback);
            });
            return;
        }
        _super.prototype.fetch.call(this, session, value, value, path, depth, callback);
    };
    EntityMapping.prototype.fetchInverse = function (session, parentEntity, propertyName, path, depth, callback) {
        var _this = this;
        if (!parentEntity) {
            return callback(new persistenceError_1.PersistenceError("Parent entity required to resolve inverse relationship."));
        }
        session.getPersister(this).findOneInverseOf(parentEntity, propertyName, function (err, value) {
            if (err)
                return callback(err);
            _super.prototype.fetch.call(_this, session, _this, value, path, depth, callback);
        });
    };
    EntityMapping.prototype.fetchPropertyValue = function (session, value, property, callback) {
        session.getPersister(this).fetchPropertyValue(value, property, callback);
    };
    EntityMapping.prototype.getDefaultFields = function () {
        var fields = {};
        if (this._defaultFields === undefined) {
            // find any lazy fields and mark them with a 0 so they are not loaded
            for (var i = 0; i < this.properties.length; i++) {
                var property = this.properties[i];
                if ((property.flags & 2048 /* FetchLazy */) != 0) {
                    property.setFieldValue(fields, 0);
                }
            }
            this._defaultFields = fields;
        }
        return this._defaultFields;
    };
    EntityMapping.prototype.resolveCore = function (context) {
        if (!context.isFirst) {
            context.setError("Unable to resolve entity mapping. The dot notation can only be used for embedded objects.");
            return;
        }
        _super.prototype.resolveCore.call(this, context);
    };
    return EntityMapping;
}(classMapping_1.ClassMapping));
exports.EntityMapping = EntityMapping;
