"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async = require("async");
var persistenceError_1 = require("./persistenceError");
/**
 * @hidden
 */
var Batch = /** @class */ (function () {
    function Batch() {
        this._commandTable = [];
        this._commands = [];
        this._executed = false;
    }
    /**
     * Gets a command from the batch.
     * @param id The id of the command.
     * @returns The command or undefined if the id cannot be found.
     */
    Batch.prototype.getCommand = function (id) {
        return this._commandTable[id];
    };
    /**
     * Adds a command to the batch.
     * @param id Number that uniquely identifies the command.
     * @param command The command to add.
     */
    Batch.prototype.addCommand = function (id, command) {
        if (this._commandTable[id]) {
            throw new persistenceError_1.PersistenceError("Batch already contains a command with id '" + id + "'.");
        }
        // make sure command has a priority
        if (command.priority == null) {
            command.priority = 50 /* Medium */;
        }
        this._commandTable[id] = command;
        this._commands.push(command);
    };
    /**
     * Executes the batch.
     * @param callback Callback called when execution completes.
     */
    Batch.prototype.execute = function (callback) {
        if (this._executed) {
            throw new persistenceError_1.PersistenceError("Batch had already been executed.");
        }
        this._executed = true;
        if (this._commands.length == 0) {
            process.nextTick(callback);
            return;
        }
        var self = this;
        // sort the commands in priority order
        this._commands.sort(commandSorter);
        executeCommands();
        function executeCommands(err) {
            // if we got an error or there are no commands left then call the callback.
            if (err || self._commands.length == 0) {
                callback(err);
                return;
            }
            // execute all commands with the same priority in parallel
            var priority = self._commands[0].priority, count = 0;
            // count the number of commands that have the same priority
            while (count < self._commands.length && self._commands[count].priority == priority) {
                count++;
            }
            async.each(self._commands.splice(0, count), function (command, done) { return command.execute(done); }, executeCommands);
        }
    };
    return Batch;
}());
exports.Batch = Batch;
function commandSorter(a, b) {
    // higher priority commands come first
    return b.priority - a.priority;
}
