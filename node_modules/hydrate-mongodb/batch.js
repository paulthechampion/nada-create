"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async = require("async");
var persistenceError_1 = require("./persistenceError");
var Batch = (function () {
    function Batch() {
        this._commandTable = [];
        this._commands = [];
        this._executed = false;
    }
    Batch.prototype.getCommand = function (id) {
        return this._commandTable[id];
    };
    Batch.prototype.addCommand = function (id, command) {
        if (this._commandTable[id]) {
            throw new persistenceError_1.PersistenceError("Batch already contains a command with id '" + id + "'.");
        }
        if (command.priority == null) {
            command.priority = 50;
        }
        this._commandTable[id] = command;
        this._commands.push(command);
    };
    Batch.prototype.execute = function (callback) {
        if (this._executed) {
            throw new persistenceError_1.PersistenceError("Batch had already been executed.");
        }
        this._executed = true;
        if (this._commands.length == 0) {
            process.nextTick(callback);
            return;
        }
        var self = this;
        this._commands.sort(commandSorter);
        executeCommands();
        function executeCommands(err) {
            if (err || self._commands.length == 0) {
                callback(err);
                return;
            }
            var priority = self._commands[0].priority, count = 0;
            while (count < self._commands.length && self._commands[count].priority == priority) {
                count++;
            }
            async.each(self._commands.splice(0, count), function (command, done) { return command.execute(done); }, executeCommands);
        }
    };
    return Batch;
}());
exports.Batch = Batch;
function commandSorter(a, b) {
    return b.priority - a.priority;
}
