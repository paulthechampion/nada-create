import * as mongodb from "mongodb";
import { EntityMapping } from "./mapping/entityMapping";
import { ResultCallback } from "./core/callback";
import { InternalSession } from "./session";
import { ChangeTrackingType } from "./mapping/mappingModel";
import { IdentityGenerator } from "./config/configuration";
import { Batch } from "./batch";
import { Callback } from "./core/callback";
import { QueryDefinition } from "./query/queryDefinition";
import { QueryDocument } from "./query/queryBuilder";
import { Observer } from "./observer";
import { Property } from "./mapping/property";
/**
 * @hidden
 */
export interface Persister {
    changeTracking: ChangeTrackingType;
    identity: IdentityGenerator;
    areDocumentsEqual(context: DirtyCheckContext, entity: Object, originalDocument: Object): boolean;
    dirtyCheck(batch: Batch, entity: Object, originalDocument: Object): Object;
    addInsert(batch: Batch, entity: Object): Object;
    addRemove(batch: Batch, entity: Object): void;
    fetch(entity: Object, path: string, callback: Callback): void;
    fetchPropertyValue(entity: any, property: Property, callback: ResultCallback<any>): void;
    refresh(entity: Object, callback: ResultCallback<Object>): void;
    watch(value: any, observer: Observer): void;
    executeQuery(query: QueryDefinition, callback: ResultCallback<any>): void;
    findOneById(id: any, callback: ResultCallback<any>): void;
    findInverseOf(entity: Object, path: string, callback: ResultCallback<Object[]>): void;
    findOneInverseOf(entity: Object, path: string, callback: ResultCallback<Object>): void;
}
export interface DirtyCheckContext {
    error?: Error;
}
/**
 * @hidden
 */
export declare class PersisterImpl implements Persister {
    changeTracking: ChangeTrackingType;
    identity: IdentityGenerator;
    private _versioned;
    private _findQueue;
    private _mapping;
    private _collection;
    private _session;
    private _criteriaBuilder;
    private _updateDocumentBuilder;
    private _traceEnabled;
    private _defaultFields;
    constructor(session: InternalSession, mapping: EntityMapping, collection: mongodb.Collection);
    dirtyCheck(batch: Batch, entity: Object, originalDocument: Object): Object;
    areDocumentsEqual(context: DirtyCheckContext, entity: Object, originalDocument: Object): boolean;
    private _dirtyCheck(context, entity, originalDocument);
    addInsert(batch: Batch, entity: Object): Object;
    addRemove(batch: Batch, entity: any): void;
    /**
     * Refreshes the managed entity with the state from the database, discarding any unwritten changes. The new
     * document is returned in the callback. There is no need to return the entity since the caller already has
     * the entity.
     * @param entity The entity to refresh.
     * @param callback The callback to call when method completes. The results parameter contains the new database
     * document.
     */
    refresh(entity: any, callback: ResultCallback<Object>): void;
    watch(value: any, observer: Observer): void;
    private _refreshFromDocument(entity, document, callback);
    fetch(entity: any, path: string, callback: Callback): void;
    /**
     * Fetches a property value from the collection.
     * @param entity The entity to load the property on.
     * @param property The property to fetch.
     * @param callback Called after the property has been loaded.
     */
    fetchPropertyValue(entity: any, property: Property, callback: ResultCallback<any>): void;
    findInverseOf(entity: Object, path: string, callback: ResultCallback<any[]>): void;
    findOneInverseOf(entity: Object, path: string, callback: ResultCallback<any>): void;
    /**
     * Returns a query for finding an inverse relationship. If an error occurs, the callback is called; otherwise,
     * the callback is not called and is left to the caller to handle. Note that the query prepared does not include
     * a discriminator but since we assume that ids are globally unique, this doesn't matter.
     * @param entity The entity that has the inverse relationship
     * @param path The map to the property in the entity that is the owning side of the relationship.
     * @param callback Callback called on error.
     */
    _prepareInverseQuery(entity: Object, path: string, callback: ResultCallback<any>): QueryDocument;
    findOneById(id: any, callback: ResultCallback<any>): void;
    findOne(criteria: QueryDocument, callback: ResultCallback<any>): void;
    private _findOne(query, callback);
    findAll(criteria: QueryDocument, callback: ResultCallback<any[]>): void;
    private _findAll(query, callback);
    executeQuery(query: QueryDefinition, callback: ResultCallback<any>): void;
    private _executeQuery(query, callback);
    private _createTraceableCallback(query, callback);
    private _prepareOrderDocument(sorting, callback);
    private _findEach(query, callback);
    private _findEachSeries(query, callback);
    private _findCursor(query, callback);
    private _prepareFind(query);
    private _findOneAndModify(query, callback);
    private _removeOne(query, callback);
    private _removeAll(query, callback);
    private _updateOne(query, callback);
    private _updateAll(query, callback);
    private _distinct(query, callback);
    private _count(query, callback);
    private _fetchOne(query, callback);
    private _fetchAll(query, callback);
    private _fetchIterator(query);
    private _loadOne(document, reference, callback);
    private _getCommand(batch);
}
/**
 * Cursor to retrieve entities.
 * @hidden
 */
export interface Cursor<T> {
    /**
     * Gets the next entity from the cursor.
     * @param callback Called with the next entity.
     */
    next(callback: ResultCallback<T>): void;
    /**
     * Closes the cursor.
     * @param callback Called when the cursor is closed.
     */
    close(callback?: Callback): void;
}
