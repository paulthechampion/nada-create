import * as mongodb from "mongodb";
import { EntityMapping } from "./mapping/entityMapping";
import { ResultCallback } from "./core/callback";
import { InternalSession } from "./session";
import { ChangeTrackingType } from "./mapping/mappingModel";
import { IdentityGenerator } from "./config/configuration";
import { Batch } from "./batch";
import { Callback } from "./core/callback";
import { QueryDefinition } from "./query/queryDefinition";
import { QueryDocument } from "./query/queryBuilder";
import { Observer } from "./observer";
import { Property } from "./mapping/property";
export interface Persister {
    changeTracking: ChangeTrackingType;
    identity: IdentityGenerator;
    areDocumentsEqual(context: DirtyCheckContext, entity: Object, originalDocument: Object): boolean;
    dirtyCheck(batch: Batch, entity: Object, originalDocument: Object): Object;
    addInsert(batch: Batch, entity: Object): Object;
    addRemove(batch: Batch, entity: Object): void;
    fetch(entity: Object, path: string, callback: Callback): void;
    fetchPropertyValue(entity: any, property: Property, callback: ResultCallback<any>): void;
    refresh(entity: Object, callback: ResultCallback<Object>): void;
    watch(value: any, observer: Observer): void;
    executeQuery(query: QueryDefinition, callback: ResultCallback<any>): void;
    findOneById(id: any, callback: ResultCallback<any>): void;
    findInverseOf(entity: Object, path: string, callback: ResultCallback<Object[]>): void;
    findOneInverseOf(entity: Object, path: string, callback: ResultCallback<Object>): void;
}
export interface DirtyCheckContext {
    error?: Error;
}
export declare class PersisterImpl implements Persister {
    changeTracking: ChangeTrackingType;
    identity: IdentityGenerator;
    private _versioned;
    private _findQueue;
    private _mapping;
    private _collection;
    private _session;
    private _criteriaBuilder;
    private _updateDocumentBuilder;
    private _traceEnabled;
    private _defaultFields;
    constructor(session: InternalSession, mapping: EntityMapping, collection: mongodb.Collection);
    dirtyCheck(batch: Batch, entity: Object, originalDocument: Object): Object;
    areDocumentsEqual(context: DirtyCheckContext, entity: Object, originalDocument: Object): boolean;
    private _dirtyCheck(context, entity, originalDocument);
    addInsert(batch: Batch, entity: Object): Object;
    addRemove(batch: Batch, entity: any): void;
    refresh(entity: any, callback: ResultCallback<Object>): void;
    watch(value: any, observer: Observer): void;
    private _refreshFromDocument(entity, document, callback);
    fetch(entity: any, path: string, callback: Callback): void;
    fetchPropertyValue(entity: any, property: Property, callback: ResultCallback<any>): void;
    findInverseOf(entity: Object, path: string, callback: ResultCallback<any[]>): void;
    findOneInverseOf(entity: Object, path: string, callback: ResultCallback<any>): void;
    _prepareInverseQuery(entity: Object, path: string, callback: ResultCallback<any>): QueryDocument;
    findOneById(id: any, callback: ResultCallback<any>): void;
    findOne(criteria: QueryDocument, callback: ResultCallback<any>): void;
    private _findOne(query, callback);
    findAll(criteria: QueryDocument, callback: ResultCallback<any[]>): void;
    private _findAll(query, callback);
    executeQuery(query: QueryDefinition, callback: ResultCallback<any>): void;
    private _executeQuery(query, callback);
    private _createTraceableCallback(query, callback);
    private _prepareOrderDocument(sorting, callback);
    private _findEach(query, callback);
    private _findEachSeries(query, callback);
    private _findCursor(query, callback);
    private _prepareFind(query);
    private _findOneAndModify(query, callback);
    private _removeOne(query, callback);
    private _removeAll(query, callback);
    private _updateOne(query, callback);
    private _updateAll(query, callback);
    private _distinct(query, callback);
    private _count(query, callback);
    private _fetchOne(query, callback);
    private _fetchAll(query, callback);
    private _fetchIterator(query);
    private _loadOne(document, reference, callback);
    private _getCommand(batch);
}
export interface Cursor<T> {
    next(callback: ResultCallback<T>): void;
    close(callback?: Callback): void;
}
