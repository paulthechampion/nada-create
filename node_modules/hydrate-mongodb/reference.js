"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var persistenceError_1 = require("./persistenceError");
/**
 * @hidden
 */
var Reference = /** @class */ (function () {
    function Reference(mapping, _id) {
        this.mapping = mapping;
        this._id = _id;
        if (_id != null) {
            this.id = _id.toString();
        }
    }
    Reference.prototype.fetch = function (session, callback) {
        if (!this.mapping) {
            callback(new persistenceError_1.PersistenceError("Object type is not mapped as an entity."));
            return;
        }
        if (this._id == null) {
            callback(new persistenceError_1.PersistenceError("Missing or invalid identifier."));
            return;
        }
        session.getPersister(this.mapping).findOneById(this._id, callback);
    };
    /**
     * Returns true if other is another reference with the same id or the resolved entity for the reference.
     * @param other The reference or entity to compare.
     */
    Reference.prototype.equals = function (other) {
        return Reference.areEqual(this, other);
    };
    /**
     * Returns true if values are equivalent. Either value can be a Reference or an Entity.
     * @param value1 The first reference or entity to compare.
     * @param value2 The second reference or entity to compare.
     */
    Reference.areEqual = function (value1, value2) {
        if (value1 == value2)
            return true;
        if (value1 == null || value2 == null)
            return false;
        if (Reference.isReference(value1)) {
            var mapping1 = value1.mapping;
            var id1 = value1._id;
        }
        else {
            // if value is not a Reference, we assume it's an Entity
            var id1 = value1._id;
        }
        if (Reference.isReference(value2)) {
            var mapping2 = value2.mapping;
            var id2 = value2._id;
        }
        else {
            // if value is not a Reference, we assume it's an Entity
            var id2 = value2._id;
        }
        // if neither value is a Reference, then return false
        if (mapping1 == null && mapping2 == null)
            return false;
        // if we are not able to find both identifiers, then return false
        if (id1 == null || id2 == null)
            return false;
        // No need to check that the mappings are equivalent since the identifiers are assumed to be globally
        // unique. The identity generator's 'areEqual' function should return false if identifier types are
        // not compatible.
        return (mapping1 || mapping2).inheritanceRoot.identity.areEqual(id1, id2);
    };
    Reference.isReference = function (obj) {
        return obj instanceof Reference;
    };
    /**
     * Fetches the Reference if the object is a Reference; otherwise, returns the passed object in the callback.
     * @param session The current session.
     * @param obj The object to fetch.
     * @param callback Called with the fetched object.
     */
    Reference.fetch = function (session, obj, callback) {
        if (Reference.isReference(obj)) {
            obj.fetch(session, callback);
        }
        else {
            callback(null, obj);
        }
    };
    return Reference;
}());
exports.Reference = Reference;
